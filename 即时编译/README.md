
# 即时编译

*作者注：我结合了多篇官网的文档，对目录进行了重新编排，也加入了个人的理解。*

即时编译器（JIT，下文直接使用JIT指代即时编译）是OpenJ9虚拟机（JVM，下文直接使用JVM指代OpenJ9虚拟机）
一个关键的组件，它可以在程序运行时将字节码(操作系统无关的抽象)
编译为机器码，以改进程序的性能。
如果禁用JIT，JVM会逐条将字节码解释为机器码并执行，解释期间会占用额外的CPU和内存，会拖慢应用的运行速度。

启用JIT的情况下，程序运行到每个方法，JVM会直接调用该方法的已编译代码，而不是解释代码。
理论上，如果编译不需要占用CPU和内存，那么即时编译所有方法就可能让Java程序速度无限接近于应用本身的速度（C语言编写的应用，机器码编写的应用）。

JIT并不会在第一次调用方法就进行编译，也不会在调用任何方法时都进行编译。JVM 
首次启动时，将调用数千种方法，即使通过JIT最终实现了较高的峰值性能，但编译所有这些方法也会对启动时间产生显著影响。
因此**分层编译追求的是启动性能和峰值性能之间的平衡**。

JVM
会保留一个方法调用计数，初始为预定义的即时编译阈值，每次调用方法时**递减**。当调用计数达到0
时，就触发方法的即时编译。只要方法被即时编译过，再次执行该方法时，JVM就不会解释而是直接调用已编译的机器码。

## JIT编译器如何优化代码
在选中某个方法进行编译时（达到阈值或满足条件），JVM会将方法的字节码提供给Just-In-Time (JIT) 编译器。JIT必须了解字节码的语义和语法，才能正确编译方法。

为帮助JIT编译器分析方法，首先会在一个内部称为方法树的结构中重新表示字节码，树相比字节码，更加接近于机器码；然后，对方法树执行分析和优化；
最后，方法树将转换为机器码。

JIT编译器可以使用多个编译线程来执行JIT编译任务，使用多线程可能有助于更快地启动Java应用程序。
**实际实践中，只有系统中存在未使用的处理核时，使用多个JIT编译线程才能提高性能。**

默认编译线程数由JVM确定，取决于操作系统的配置。如果默认编译线程数并非最佳，你可以使用[-XcompilationThreads](./../命令行参数/JVM-X参数/-XcompilationThreads.md)参数来覆盖JVM的默认值。


### 优化阶段
编译需要对方法树进行分析和优化，包括以下几个阶段，只有最后一个阶段才会产生机器码，其他阶段都是字节码

    作者注：我理解优化阶段在真实优化时是个路径的概念，并不一定按部就班是1-2-3-4-5，有可能是1-5，2-5等等，这可能根据优化级别不同而有所不同。

### 阶段1-内联
内联是将较小方法树并入，或“内联”到其调用者树的过程。这可加快对经常执行的方法的调用速度。根据当前优化级别，使用具有不同活跃级别的两种内联算法。
此阶段执行的优化包括：
* 细琐内联
* 调用图内联
* 尾部递归消除
* 虚拟调用监管优化

#### 阶段2-局部优化
局部优化一次分析和改进一小部分代码。很多局部优化是典型的静态编译器中已经测试过并使用的技术。此阶段执行的优化包括：
* 局部数据流分析和优化
* 寄存器使用优化
* Java代码模式简化
重复应用这些技术，尤其是在全局优化后，这可以指出更多改进的地方。

#### 阶段3-控制流优化
控制流优化分析方法内部的控制流（或者特定部分）并重新安排代码路径以提高效率。此阶段执行的优化包括：
* 代码重新排序、分割和除去
* 循环缩减和循环反演
* 循环步幅和循环不变量代码移动
* 循环展开和剥离
* 循环版本控制和专用化
* 异常定向优化
* 转换分析

#### 阶段4-全局优化
全局优化立即对整个方法生效。全局优化“成本更高”，需要更多的编译时间，但可显著提高性能。此阶段执行的优化包括：
* 全局数据流分析和优化
* 部分冗余消除
* 逃逸分析
* GC和内存分配优化
* 同步优化

#### 阶段5-生成机器码
生成机器码的过程根据操作系统体系结构的不同而有所不同。通常，在此编译阶段，方法树将转换为机器码指令，并根据操作系统体系结构特征执行一些较小的优化。
已完成编译的代码将放入JVM过程空间中的代码高速缓存（ code cache）；方法对应的代码高速缓存的地址也会被记录，以供今后调用已编译的代码而使用。
在任何指定的时间，JVM进程由JVM可执行文件和一组JIT编译的代码组成，这些JIT编译的代码会动态连接到JVM中的字节码解释器。


### 优化级别
JIT编译器可以在不同的优化级别编译方法，级别包括：cold、warm、hot、veryHot（带profiling）
 或 scorching，可以参考[-Xjit](../命令行参数/JVM-X参数/-Xjit)。
 **优化级别越高，预期的性能也越高，但它们在CPU和内存方面的性能开销也越高。** 

 * cold：在大型应用程序启动时会降级到cold，以缩短启动时间。
 * warm：初始或缺省优化级别为warm，在启动成功后，大部分方法会因为达到编译阈值而被即时编译。
 
 
    作者注：我理解优化级别主要考量两点：
     * 代码多热，就可以编译
     * 编译优化到哪个阶段就进化到生成机器码

JIT向更高级别级别进化时，需要使用一个采样线程，该线程会定期唤醒并确定哪些方法更频繁出现在堆栈顶部。
开销超过1%的方法会使用hot级别编译，开销超过12.5%的方法会有机会使用scorching级别编译，不过，很可能使用scorching级别编译之前，该方法就会由于采样线程搜集到详细的数据，而已经使用very hot级别编译过了。

越高级别的编译，越会采取特别的技术，可以参考编译阶段的阶段4。虽然这些技术会消耗更多的CPU和内存，但可显著提高性能。

## JIT编译器的使用

### 禁用和启用JIT编译器
关闭JIT是临时性措施，有助于在调试Java应用程序时隔离问题。有两种方式禁用JIT：

*在命令行上使用-D选项将java.compiler属性设置为NONE或空字符串，如下：
    
    java -Djava.compiler=NONE <class>
                                      
*在命令行上使用-Xnojit选项，如下：

    java -Xnojit <class>
    
缺省情况下，JIT是启用的。有多种方式重新启用JIT：
*在命令行上使用-D选项来将java.compiler属性设置为jitc
    
    java -Djava.compiler=jitc <class>
    
*在命令行上使用-Xjit选项，如下：

    java -Xjit <class>
    
注意：-Xint选项将同时禁用JIT和AOT编译器。

### 确定是否已启用JIT
可以使用java -version 命令确定JIT的状态。如果JIT没在使用，将显示(JIT disabled)；如果JIT在使用，将显示(JIT enabled)

    /home/zenap # java -version
    openjdk version "1.8.0_181"
    OpenJDK Runtime Environment (build 1.8.0_181-b13)
    Eclipse OpenJ9 VM (build openj9-0.9.0, JRE 1.8.0 Linux amd64-64-Bit Compressed References 20180813_291 (JIT enabled, AOT enabled)
    OpenJ9   - 24e53631
    OMR      - fad6bf6e
    JCL      - a05586ac based on jdk8u181-b13)

### JIT与JVM
JIT与JVM两者关系紧密。也就是说，同一个JVM使用不同的JIT版本是不可以的，换用另一个厂商的JIT也是不可以的。

### 动态控制JIT编译器
 JIT编译器与JVM同时启动，因此在启动前就要通过选项来修改它的行为。不过，Java应用程序可以使用 java.lang.Compiler API在运行时启用或禁用JIT编译器
 
### 代码高速缓存（code cache）占用内存情况
JIT编译器会智能地使用内存。初始化代码高速缓存时，它占用的内存相对较少。在将更多方法编译为机器码时，代码高速缓存将会动态增长以适应程序的需求。
将会回收和复用先前丢弃的或重新编译的方法占用的空间。在代码高速缓存的大小到达预定义的最大阈值时，将停止增长。
然后，JIT编译器会停止编译所有方法，以避免耗尽系统内存或影响应用程序或操作系统的稳定性。从 z/OS V2.3 开始，缺省情况下会启用64位应用程序的驻留模式 (RMODE64)。此功能允许JIT分配的代码高速缓存超过2GB的上限。您可以通过在命令行上指定-Xjit:disableRMODE64子选项来禁用此JIT功能。

![Code Cache](./1.png)
    
      作者注：JIT的代码高速缓存上限应该是2G。注意，代码高速缓存是在堆外，在容器环境需要密切关注其大小，一旦堆内存+堆外内存的总和
      超过了操作系统给容器分配的阈值，操作系统会将容器杀死。由于堆内存并没有超过阈值，所以不会有dump，所以较难于定位这类问题
      
### JIT编译器开启下的快速启动

JIT编译器针对服务器上通常长时间运行的应用程序进行了调优。您可以使用 -Xquickstart 命令行选项来提高短时间运行的应用程序的性能。

-Xquickstart选项使得JIT编译器在缺省情况下使用较低的优化级别。当AOT编译器激活的情况下（同时启用了共享类和 AOT 编译）时，-Xquickstart 选项将导致所有选择编译的方法由AOT编译，这将缩短后续运行的启动时间。如果将 -Xquickstart 用于长时间运行的应用程序并且应用程序中包含使用大量处理资源的方法，其性能会下降。-Xquickstart 的执行会根据将来发行版的变化而相应调整

## JIT编译的诊断

缺省情况下，JIT编译器将启用以改进应用性能。即便如此，如果你怀疑JIT出现问题，临时禁用JIT，将可以帮助你诊断问题。

由于JVM启动的同时也启动了JIT，因此你只能在启动前调整JIT参数。

有多种方法禁用JIT：
* 在命令行指定-Djava.compiler=NONE
* 在命令行指定[-Xjit](../命令行参数/JVM-X参数/-Xjit)
，该参数可以关闭JIT和AOT编译器。如果想要确定是哪种编译器导致的问题，也可以选择性的使用-Xnojit和-Xnoaot参数
* 在编程期间调用java.lang.Compiler API，不过这个API在Java SE9中已经被移除

如果关闭JIT解决了你的问题，你可以进一步通过一些参数来观察JIT的详细信息。

Turning on verbose logging with the verbose suboption causes the JIT to record all compiler operations. However, the log file can be difficult to read because there are so many complex operations occuring in rapid succession. Follow these steps to simplify operations, which helps you pinpoint the root cause:

### 理解JIT的详细信息

