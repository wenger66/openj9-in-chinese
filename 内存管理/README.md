# 内存管理

## [全局垃圾回收](https://www.ibm.com/support/knowledgecenter/SSYKE2_8.0.0/com.ibm.java.vm.80.doc/docs/mm_gc_heapshrinkage.html)

### [堆扩展](https://www.ibm.com/support/knowledgecenter/SSYKE2_8.0.0/com.ibm.java.vm.80.doc/docs/mm_gc_heapexpansion.html)

### [堆收缩](https://www.ibm.com/support/knowledgecenter/SSYKE2_8.0.0/com.ibm.java.vm.80.doc/docs/mm_gc_heapshrinkage.html)


## 如何调整堆大小

### 初始堆大小和最大堆大小

了解垃圾回收器的操作有助于设置初始堆大小和最大堆大小，以实现对堆的高效管理

垃圾回收器会进行操作以将堆占用率保持在 30% 到 60% 之间：
* 堆占用率大于 60% 会导致更频繁的 GC 周期，会导致性能降低。可以通过设置 [-Xminf](../命令行参数/JVM-X参数/-Xminf.md) 选项来改变 60% 的阈值。
* 堆占用率小于 30% 意味着不频繁的 GC 周期。但是，这些GC周期会导致更长的暂停时间，也会导致性能降低。可以通过设置 [-Xmaxf](../命令行参数/JVM-X参数/-Xmaxf.md) 选项来改变 30% 的阈值。

如果你未设置初始堆大小和最大堆大小，GC会根据需要扩展和缩小 Java 堆。但是，如果使用 -Xms 和 -Xmx 选项设置堆大小，那么 GC 不会扩展或缩小 Java 堆。
为了优化应用程序性能，并将堆占用率保持在 30% - 60% 范围内，那么 -Xmx 设置应至少比应用程序的最大内存占用值高出 66% 。例如如果应用程序最大占用值为60MB，那么 -Xmx 应设置为100MB，计算公式如下：
    60 + (60 * 66/100) = 100
    
**作者注：GC中的压缩和整理可以等同理解，都是将堆碎片合并，以得到更大的空闲空间。下文都描述为整理**
    
**将 -Xms 和 -Xmx 设置为相同值通常不是很好的做法**。因为这种设置下，GC会延迟到堆充满后才开始（？），而且 GC 第一次运行可能会花费更长的时间。
此外，堆可能会出现碎片，需要整理，以应用程序所需的最小堆大小启动应用程序，由于堆较小，GC会频繁且高效地运行。

如果 GC 无法找到足够的垃圾，将进行整理。如果 GC 找到了足够的垃圾，或者满足堆扩展的任何其他条件，那么 GC 将扩展堆。

应用程序通常会运行到堆满为止。 然后，连续的垃圾回收周期将恢复空间。在堆装满活动对象时，GC 将整理堆。如果仍未恢复足够的垃圾，那么 GC 将扩展堆。

从先前的描述中，你可以看到，随着应用程序需求的增加，GC 将整理堆，因此，在堆扩展时，一些经过整理合并的对象就会在堆的底部。由于在发现需要整理时
才以可能的最小堆大小运行整理，因此该过程是一种高效的管理堆的方式。随着堆的增加，GC 将以最小的堆大小来执行整理。一些迹象表明，
应用程序初始化时创建的对象很可能是键或根对象，因此较早地整理能够为短生命周期的对象提供更大的堆空间。

最终，JVM 堆大小将达到最大值，所有长生命周期对象被整理在堆的底部。当整理成本较低时，将进行整理。
与收集和整理非常大的堆碎片的成本相比，扩展堆的成本是微乎其微。