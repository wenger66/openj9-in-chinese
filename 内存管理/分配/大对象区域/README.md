# 大对象区域

大对象区域 (LOA=large object area) 是老年代中一块单独使用的堆区域，用于满足大对象分配。 当分配请求不能在堆的主区域（也被视为小对象区域 (SOA=small object area)）被满足时，就会使用 LOA。

在经过不断的分配和回收对象后，堆会碎片化，此时对象分配的请求，可能在耗时的整理后才可能被满足，该问题在应用程序分配大对象时更加明显。为了尝试减轻该问题，就会使用LOA区域。这里说的大对象是指大小为 64 KB 或更大的任何对象。 对新 TLH （thread local heap）的分配不认为是大对象的请求。 缺省情况下，除均衡垃圾回收策略之外的所有 GC 策略都有大对象区域，但是，如果不使用，那么在执行一些回收后大对象区域的大小将收缩为 0。可以通过指定 [-Xnoloa](../../../命令行参数/JVM-X参数/-Xnoloa.md) 命令行选项来显式禁用该区域。

均衡垃圾回收策略不会使用 LOA。 因此，当指定 -Xgcpolicy:balanced 时， 将会忽略任何传递到命令行的 LOA 选项。该策略通过利用 JVM 识别对象布局解决 LOA 问题，以便减少堆分段存储和压缩需求。 该项更改完全包含在 JVM 中，不需要做任何的Java代码更改。


## 初始化和 LOA
在初始化堆时会计算 LOA 区域边界，并在每次垃圾回收后重新计算 LOA 区域边界。可使用以下命令行选项来控制 LOA 的大小：[-Xloainitial](../../../命令行参数/JVM-X参数/-Xloainitial.md) 和 [-Xloamaximum](../../../命令行参数/JVM-X参数/-Xloamaximum.md)。

选项的值在 0 和 0.95 范围内（表示占用老年区堆大小的 0% 到 95%）。缺省值为：
 * -Xloainitial0.05 (5%)
 * -Xloaminimum0 (0%)
 * -Xloamaximum0.5 (50%)
 
## LOA 扩展和收缩
垃圾收集器根据使用情况扩展或收缩 LOA。

垃圾收集器使用以下算法：
    *如果在 SOA 上发生分配失败：
        * 如果当前 LOA 的大小大于其初始大小，并且 LOA 中可用空间量超过 70%，那么将分配给 LOA 的空间百分比减少 1%。
        * 如果当前 LOA 的大小等于或小于其初始大小，并且 LOA 中可用空间量超过 90%：
            * 如果当前 LOA 的大小大于堆大小的 1%，那么将分配给 LOA 的空间百分比减少 1%。
            * 如果当前 LOA 的大小是堆大小的 1% 或更小，那么将分配给 LOA 的空间百分比减少 0.1%。
    * 如果在 LOA 上发生分配失败：
        * 如果分配请求的大小大于当前 LOA 大小的 20%，那么将分配给 LOA 的空间百分比增加 1%。
        * 如果当前 LOA 的大小小于其初始大小，并且 LOA 中可用空间量小于 50%，那么将分配给 LOA 的空间百分比增加 1%。
        * 如果当前 LOA 的大小等于或大于其初始大小，并且 LOA 中可用空间量小于 30%，那么将分配给 LOA 的空间百分比增加 1%。

## LOA 中的分配
分配请求的大小决定了如何分配对象

在分配对象时，首先尝试在小对象区域 (SOA) 中进行分配。如果找不到足够大小的可用空间，并且请求的大小等于或大于 64 KB，那么将再次在 LOA 中尝试分配。
如果请求大小小于 64 KB 或者在 LOA 中没有足够的连续空间，那么将触发分配失败事件。